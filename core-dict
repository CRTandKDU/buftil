* DICT
# Stack operations
** DUP primitive
(let ((x (buftil-pop))) (buftil-push x) (buftil-push x))

** DROP primitive
(buftil-pop)

** SWAP primitive
(let ((x (buftil-pop)) (y (buftil-pop))) (buftil-push x) (buftil-push y))

** OVER primitive
(let ((x (buftil-pop)) (y (buftil-pop))) (buftil-push y) (buftil-push x) (buftil-push y))

** RROT primitive
(let ((a (buftil-pop)) (b (buftil-pop)) (c (buftil-pop))) (buftil-push b) (buftil-push a) (buftil-push c))

** LROT primitive
(let ((a (buftil-pop)) (b (buftil-pop)) (c (buftil-pop))) (buftil-push a) (buftil-push c) (buftil-push b))

** <R primitive
(buftil-push (buftil-pop) "CALL")

** >R primitive
(buftil-push (buftil-pop "CALL"))

# Arithmetics
** ADD primitive
(let ((x (buftil-pop)) (y (buftil-pop))) (buftil-push (+ (string-to-number x) (string-to-number y))))

** SUB primitive
(let ((x (buftil-pop)) (y (buftil-pop))) (buftil-push (- (string-to-number y) (string-to-number x))))

** MUL primitive
(let ((x (buftil-pop)) (y (buftil-pop))) (buftil-push (* (string-to-number x) (string-to-number y))))

** DIV primitive
(let ((x (buftil-pop)) (y (buftil-pop))) (buftil-push (/ (string-to-number y) (string-to-number x))))

# TIL implementation
** = primitive
(if (string= (buftil-pop) (buftil-pop)) (buftil-push 1) (buftil-push 0)) 

** < primitive
(if (< (string-to-number (buftil-pop)) (string-to-number (buftil-pop))) (buftil-push 1) (buftil-push 0))

** > primitive
(if (> (string-to-number (buftil-pop)) (string-to-number (buftil-pop))) (buftil-push 1) (buftil-push 0))

** ; primitive immediate
(buftil-create-footer)
(buftil--set-variable "MODE" "EXECUTION")

** SEMI primitive
(let ((ret (buftil-pop "CALL"))) (buftil-set-wordreg ret))

** : primitive
(buftil-create-header)
(buftil--set-variable "MODE" "COMPILE")

** CREATE primitive
(buftil-create-header)

** COLON primitive
nil

** BEGIN primitive immediate
(buftil-push (buftil-create-line-number) "CALL")

** END primitive immediate
(buftil-create-body "<JNZ>\n")
(buftil-create-body (format "%s\n" (- (string-to-number (buftil-pop "CALL")) (buftil-create-line-number))))

** <JNZ> primitive
(buftil-jump-relative-not-zero-wordreg)

** <JZ> primitive
(buftil-jump-relative-if-zero-wordreg)

** IF primitive immediate
(buftil-create-body "<JZ>\n")
(buftil-push (buftil-create-line-number) "CALL")
(buftil-create-body "\n")

** THEN primitive immediate
(buftil-update-body (buftil-pop "CALL") (buftil-create-line-number))

** CODE primitive
(buftil-create-body-from-code)

** ;CODE primitive
(buftil-create-body "SEMI\n\n")

** CODESTACK primitive
(buftil-create-body-from-stack)

** CODECALL primitive
(buftil-create-body-from-call)

** . primitive
(buftil-pop-print)

* END
