* DICT
# Stack operations
** DUP primitive
(let ((x (pop))) (push x) (push x))

** DROP primitive
(pop)

** SWAP primitive
(let ((x (pop)) (y (pop))) (push x) (push y))

** OVER primitive
(let ((x (pop)) (y (pop))) (push y) (push x) (push y))

** RROT primitive
(let ((a (pop)) (b (pop)) (c (pop))) (push b) (push a) (push c))

** LROT primitive
(let ((a (pop)) (b (pop)) (c (pop))) (push a) (push c) (push b))

** <R primitive
(push (pop) "CALL")

** >R primitive
(push (pop "CALL"))

# Arithmetics
** ADD primitive
(let ((x (pop)) (y (pop))) (push (+ (string-to-number x) (string-to-number y))))

** SUB primitive
(let ((x (pop)) (y (pop))) (push (- (string-to-number y) (string-to-number x))))

** MUL primitive
(let ((x (pop)) (y (pop))) (push (* (string-to-number x) (string-to-number y))))

** DIV primitive
(let ((x (pop)) (y (pop))) (push (/ (string-to-number y) (string-to-number x))))

# TIL implementation
** = primitive
(if (string= (pop) (pop)) (push 1) (push 0)) 

** < primitive
(if (< (string-to-number (pop)) (string-to-number (pop))) (push 1) (push 0))

** > primitive
(if (> (string-to-number (pop)) (string-to-number (pop))) (push 1) (push 0))

** ; primitive immediate
(create-footer)
(buftil--set-variable "MODE" "EXECUTION")

** SEMI primitive
(let ((ret (pop "CALL"))) (set-wordreg ret))

** : primitive
(create-header)
(buftil--set-variable "MODE" "COMPILE")

** CREATE primitive
(create-header)

** COLON primitive
nil

** BEGIN primitive immediate
(push (create-line-number) "CALL")

** END primitive immediate
(create-body "<JNZ>")
(create-body (format "%s" (- (string-to-number (pop "CALL")) (create-line-number))))

** <JNZ> primitive
(jump-relative-not-zero-wordreg)

** <JZ> primitive
(jump-relative-if-zero-wordreg)

** IF primitive immediate
(create-body "<JZ>")
(push (create-line-number) "CALL")
(create-body "")

** THEN primitive immediate
(update-body (pop "CALL") (create-line-number))

** CODE primitive
(create-body-code)

** CODESTACK primitive
(create-body-stack)

** CODECALL primitive
(create-body-call)

** SQUARE secondary
COLON
DUP
MUL
SEMI

** DOUBLE secondary
COLON
DUP
ADD
SEMI

** foo secondary
COLON
10
DUP
1
SUB
DUP
<JZ>
-5
SEMI

** bar secondary
COLON
<JZ>
2
"OK"
"FOLLOW"
SEMI

** quux secondary
COLON
DUP
ADD
SEMI


# : CONSTANT CREATE CODESTACK CODE "SEMI\\n" ;
** CONSTANT secondary
COLON
CREATE
CODESTACK
CODE
"SEMI\n"
SEMI

# 10 CONSTANT DIX
** DIX secondary
COLON
10
SEMI

* END
