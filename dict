* DICT
# Stack operations
** DUP primitive
(let ((x (pop))) (push x) (push x))

** DROP primitive
(pop)

** SWAP primitive
(let ((x (pop)) (y (pop))) (push x) (push y))

** OVER primitive
(let ((x (pop)) (y (pop))) (push y) (push x) (push y))

** RROT primitive
(let ((a (pop)) (b (pop)) (c (pop))) (push b) (push a) (push c))

** LROT primitive
(let ((a (pop)) (b (pop)) (c (pop))) (push a) (push c) (push b))

** <R primitive
(push (pop) "CALL")

** >R primitive
(push (pop "CALL"))

# Arithmetics
** ADD primitive
(let ((x (pop)) (y (pop))) (push (+ (string-to-number x) (string-to-number y))))

** SUB primitive
(let ((x (pop)) (y (pop))) (push (- (string-to-number y) (string-to-number x))))

** MUL primitive
(let ((x (pop)) (y (pop))) (push (* (string-to-number x) (string-to-number y))))

** DIV primitive
(let ((x (pop)) (y (pop))) (push (/ (string-to-number y) (string-to-number x))))

# TIL implementation
** ; primitive immediate
(create-footer)
(buftil--set-variable "MODE" "EXECUTION")

** SEMI primitive
(let ((ret (pop "CALL"))) (set-wordreg ret))

** : primitive
(create-header)
(buftil--set-variable "MODE" "COMPILE")

** COLON primitive
nil

** BEGIN primitive immediate
(push (create-line-number) "CALL")

** END primitive immediate
(create-body "<END>")
(create-body (format "%s" (pop "CALL")))

** <END> primitive
(if (= 0 (string-to-number (pop))) (let ((lineno (line-number-at-pos))) (forward-line) (set-wordreg (thing-at-point 'line t))) (set-wordreg (+ 2 (line-number-at-pos))))

** SQUARE secondary
COLON
DUP
MUL
SEMI

** DOUBLE secondary
COLON
DUP
ADD
SEMI


** foo secondary
COLON
2
1
SUB
DUP
<END>
81
SEMI

* END
